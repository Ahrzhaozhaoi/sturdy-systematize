<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
/**
* DOM事件的级别
*  DOM0：
*    element.onclick = function() {}
*  DOM2:
*    element.addEventListener('click',callback,false)
*    默认false,在冒泡阶段触发
*    true，在捕获阶段触发
*  DOM3：
*    element.addEventListener('keyup',callback,false)
*    增加了鼠标键盘事件
*
* DOM事件模型：捕获和冒泡
*
* DOM事件流：（三个阶段：捕获，目标，冒泡）
*
* 描述DOM事件捕获的具体流程：
*  window
*  window.document
*  window.document.documentElement(html标签)
*  window.document.body
*
* Event事件的常见应用
*  e.preventDefault()
*  e.stopPropagation()
*  e.stopImmediatePropagation()
*  //在事件A响应函数中加上，阻止B响应函数执行
*  e.currentTarget //指向父级元素
*  e.target //用在父级事件代理
*
* 自定义事件
*  var event = new Event('custom')
*  dom.addEventListener('custom', callback)
*  dom.dispatchEvent(event)//事件对象
*
*  CustomEvent(弥补Event不能加数据)
*  var customEvetn = new CustomEvent('custom',dataObj)
*
*3.1 这里的IE是IE11以下;
*3.2 参数的差别: attachEvent()的第一个参数
 * 比addEventListener()的事件名多一个"on"，
*    且没有第三个参数，因为IE事件模型只支持冒泡事件流;
*3.3 事件处理函数作用域的区别: IE中事件处理程序处于全局作用域，
 * 其内的this会指向window;
*而用DOM（0或2）级事件的事件处理程序的作用域是元素作用域，
 * 其内的this指向其所属的元素
*例: document.addEventListener("click", function(){
*  if(this == document){
*    alert("此时this指向document");
*  }
*}, false);
*3.4 事件对象event的属性方法的差别
*IE                    DOM
*e.cancelBubble = true  e.stopPropagation() //停止冒泡
*returnValue = false    preventDefault() //阻止元素默认事件
*srcElement            target //事件目标
*
* .DOM操作——怎样添加、移除、移动、复制、创建和查找节点？
*创建新节点
*createDocumentFragment() // 创建一个DOM片段
*createElement() // 创建一个具体的元素
*createTextNode() // 创建一个文本节点
*
*添加、移除、替换、插入
*appendChild()
*removeChild()
*replaceChild()
*insertBefore() // 在已有的子节点前插入一个新的子节点
*
*查找
*getElementsByTagName() // 通过标签名称
*getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
*getElementById() // 通过元素Id，唯一性
*
*/
</script>
</body>
</html>